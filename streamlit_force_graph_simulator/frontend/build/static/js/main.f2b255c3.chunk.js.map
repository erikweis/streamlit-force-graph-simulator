{"version":3,"sources":["Graph.tsx","index.tsx"],"names":["withStreamlitConnection","props","args","initial_graph","events","time_interval","graphprops","initial_data","nodes","links","useState","network","time","paused","statedata","setData","useEffect","Streamlit","setFrameHeight","interval","setInterval","events_list","length","e","event_type","node","filter","item","id","source","find","n","target","newlink","attributes","directed","link","propt","console","log","graph","clearInterval","Button","onClick","variant","graphData","key","Math","round","random","engine","Styletron","ReactDOM","render","StrictMode","value","document","getElementById"],"mappings":"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","file":"static/js/main.f2b255c3.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport {\n  ComponentProps,\n  Streamlit,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\";\nimport ForceGraph2D from 'react-force-graph-2d';\nimport Button from \"react-bootstrap/Button\";\n//import { ProgressBar } from \"react-bootstrap\";\nimport { Play, Pause,ArrowCounterclockwise} from 'react-bootstrap-icons';\n\n\nconst Graph = (props: ComponentProps) => {\n\n  const {initial_graph, events, time_interval, graphprops} = props.args;\n\n  let time=0;\n  let initial_data = { nodes:initial_graph.nodes, links:initial_graph.links }\n  const [statedata, setData] = useState({network:initial_data,time:time,paused:true});\n\n  useEffect(() => Streamlit.setFrameHeight());\n\n  let playpause = () => {\n    setData((statedata)=>{\n      \n      // network should be reset if pressing play after previous simulation finished\n      var network;\n      if (statedata.time === 0) {\n        network = initial_data\n      } else {\n        network = statedata.network\n      }\n\n      return {\n        network:network,\n        time:statedata.time,\n        paused: !statedata.paused\n      }\n    })\n  };\n\n  let reset = () => {\n    setData((statedata)=>{\n      return {\n        network:initial_data,\n        time:0,\n        paused:true\n      }\n    })\n  }\n\n  useEffect(()=>{\n    setData({network:initial_graph,time:0,paused:true})\n  },[props]);\n\n  useEffect(() => {\n    let interval = setInterval(() => {      \n      setData((statedata)=>{\n\n        if (statedata.paused===false) {\n\n          /////////// advance simulation ///////////\n          let network = statedata.network;\n          let time = statedata.time;\n          \n          // reset network at beginning\n          if (time === 0) {\n            network = initial_data\n          } \n          // at end of simulation pause simulation and reset time to zero\n          else if (time === events.length) {\n            return {\n              network: network,\n              time: time,\n              paused: true\n            }\n          }\n\n          //set events list\n          let events_list;\n          if (events.length>0){\n            events_list = events[time%events.length];\n          } else {\n            events_list = []\n          }\n          \n          //all events\n          let nodes = network.nodes;\n          let links = network.links;\n\n          for (var e of events_list) {\n\n            if (e.event_type === 'add_node') {\n              nodes = [...nodes,e.node]\n            } else if (e.event_type === 'remove_node'){\n              nodes = nodes.filter((item: any)=>item.id !== e.id)\n            } else if (e.event_type === 'add_link'){\n              let source = nodes.find((n:any)=>(n.id === e.source))\n              let target = nodes.find((n:any)=>(n.id === e.target))\n              let newlink = {...e.attributes,source:source,target:target}\n              links = [...links,newlink]\n            } else if (e.event_type === 'remove_link'){\n              if (e.directed === 'true'){\n                links = links.filter((item:any)=>((item.source.id !== e.source) && (item.target.id !== e.target)))\n              } else {\n                links = links.filter((link:any)=>{\n                  if ((link.source.id === e.source) && (link.target.id === e.target)) {\n                    return false\n                  } else if ((link.source.id === e.target) && (link.target.id === e.source)){\n                    return false\n                  } else {\n                    return true\n                  }\n                });\n              }\n            } else if(e.event_type=== 'node_attributes'){\n              for (var n of nodes){\n                if (n.id === e.id){\n                  for (var propt in e.attributes){\n                    n[propt]=e.attributes[propt]\n                  }\n                }\n              }\n            } else if(e.event_type === 'link_attributes'){\n              let link = links.find((item:any)=>((item.source.id === e.source) && (item.target.id === e.target)))\n              for (var propt in e.attributes){\n                link[propt]=e.attributes[propt]\n              }\n            } else if (e.event_type === 'new_graph'){\n              console.log(e.graph)\n              nodes = e.graph.nodes;\n              links = e.graph.links;\n            }\n          }\n\n          //advance time \n          time++;\n          \n          return {\n            network:{nodes:nodes, links:links},\n            time:time,\n            paused:statedata.paused\n          };\n        } else {\n          return statedata;\n        }\n      });\n      \n    },time_interval,[statedata,events,initial_data]);\n    return () => {\n      clearInterval(interval);\n    };\n  },[statedata,events,time_interval,initial_data]);\n\n  // Add a label and pass min/max variables to the baseui Slider\n  return (\n    <>\n      <Button onClick={playpause} variant={\"light\"}>{statedata.paused ? <Play/> : <Pause/>}</Button>\n      <Button onClick={reset} variant={'light'}><ArrowCounterclockwise/></Button>\n      <p>{statedata.time}/{events.length}</p>\n      <ForceGraph2D\n          graphData={statedata.network}\n          {...graphprops}\n          key={Math.round(Math.random()*100)}\n      />\n    </>\n  );\n};\n\nexport default withStreamlitConnection(Graph);","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Graph from \"./Graph\";\n\n// Lots of import to define a Styletron engine and load the light theme of baseui\nimport { Client as Styletron } from \"styletron-engine-atomic\";\nimport { Provider as StyletronProvider } from \"styletron-react\";\n\nconst engine = new Styletron();\n\n// Wrap your CustomSlider with the baseui light theme\nReactDOM.render(\n  <React.StrictMode>\n    <StyletronProvider value={engine}>\n      <Graph />\n    </StyletronProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);"],"sourceRoot":""}